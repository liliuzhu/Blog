<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[WebSocket技术分享]]></title>
    <url>%2Fblog%2F2019%2F06%2FInternal-technology-sharing-WebSocket.html</url>
    <content type="text"><![CDATA[在正式介绍WebSocket之前先跟大家科普一下以及讨论一下过去是如何实现Web双向通信的科普一下通讯传输模式单工：只支持数据在一个方向上传输；例如：BP机半双工：允许数据在两个方向上传输，但是某一时刻只允许数据在一个方向上传输；例如：对讲机, 电报机全双工：同时在两个方向上传输，是两个单工通信的结合，要求发送设备和接收设备同时具有独立的接收和发送能力。 例如：手机历史回顾HTTP 协议有一个缺陷：通信只能由客户端发起。举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。 在WebSocket协议之前，有三种实现双向通信的方式：轮询（polling）、长轮询（long-polling）和iframe流（streaming）。轮询（polling）轮询是客户端和服务器之间会一直进行连接，每隔一段时间就询问一次。其缺点也很明显：连接数会很多，一个接受，一个发送。而且 每次发送请求都会有Http的Header，会很耗流量，也会消耗CPU的利用率 。优点：实现简单，无需做过多的更改缺点：轮询的间隔过长，会导致用户不能及时接收到更新的数据；轮询的间隔过短，会导致查询请求过多，增加服务器端的负担实例1.index.html12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!--index.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;script src="https://unpkg.com/axios@0.18.0/dist/axios.min.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/vue@2.6.10/dist/vue.min.js"&gt;&lt;/script&gt; &lt;title&gt;polling&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;button @click="polling"&gt;http 轮询&lt;/button&gt; &lt;button @click="stopPolling"&gt;停止轮询&lt;/button&gt; &lt;p&gt;&#123;&#123;time&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; window.onload=function()&#123; let vm=new Vue(&#123; el:'#app', data:&#123; time: '', timer: null &#125;, mounted() &#123; &#125;, methods: &#123; polling() &#123; this.stopPolling() this.timer = setInterval(this.getTime, 1000) &#125;, stopPolling() &#123; clearInterval(this.timer) this.timer = null &#125;, getTime()&#123; window.axios.get('/polling').then(res =&gt; &#123; this.time = res.data &#125;) &#125; &#125; &#125;); &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;2.server.js12345678910111213// server.jsconst port = 8001let path = require('path');let express = require('express'), //引入express模块 app = express(), server = require('http').createServer(app);app.use(express.static(path.join(__dirname, 'static'))); //指定静态HTML文件的位置app.get('/polling',function(req,res)&#123; res.end(new Date().toLocaleString());&#125;);server.listen(port);server.setTimeout(0); //设置不超时，所以服务端不会主动关闭连接console.log('server started', 'http://127.0.0.1:' + port);3.效果图长轮询（long-polling）长轮询是对轮询的改进版，客户端发送HTTP给服务器之后，看有没有新消息，如果没有新消息，就一直等待。当有新消息的时候，才会返回给客户端。在某种程度上减小了网络带宽和CPU利用率等问题。由于http数据包的头部数据量往往很大（通常有400多个字节），但是真正被服务器需要的数据却很少（有时只有10个字节左右），这样的数据包在网络上周期性的传输，难免 对网络带宽是一种浪费 。优点：比 Polling 做了优化，有较好的时效性缺点：保持连接会消耗资源; 服务器没有返回有效数据，程序超时。实例1.index.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!--index.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;script src="https://unpkg.com/axios@0.18.0/dist/axios.min.js"&gt;&lt;/script&gt; &lt;script src="https://unpkg.com/vue@2.6.10/dist/vue.min.js"&gt;&lt;/script&gt; &lt;title&gt;long-polling&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;button @click="longPolling"&gt;http 长轮询&lt;/button&gt; &lt;button @click="stopPolling"&gt;停止轮询&lt;/button&gt; &lt;p&gt;&#123;&#123;time&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; window.onload=function()&#123; let vm=new Vue(&#123; el:'#app', data:&#123; time: '', timer: null &#125;, methods: &#123; stopPolling() &#123; this.timer = null &#125;, longPolling() &#123; if(!this.timer)&#123; this.timer = true this.getTime() &#125; &#125;, getTime()&#123; window.axios.get('/longPolling', &#123;timeout: 5000&#125;).then(res =&gt; &#123; this.time = res.data this.timer &amp;&amp; this.getTime() &#125;).catch(err =&gt; &#123; console.log(err) this.timer &amp;&amp; this.getTime() &#125;) &#125; &#125; &#125;); &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;2.server.js123456789101112131415// server.jsconst port = 8001let path = require('path');let express = require('express'), //引入express模块 app = express(), server = require('http').createServer(app);app.use(express.static(path.join(__dirname, 'static'))); //指定静态HTML文件的位置app.get('/longPolling',function(req,res)&#123; setTimeout(_ =&gt; &#123; res.end(new Date().toLocaleString()); &#125;, 1000)&#125;);server.listen(port);server.setTimeout(0); //设置不超时，所以服务端不会主动关闭连接console.log('server started', 'http://127.0.0.1:' + port);3.效果图长连接iframe流（streaming）iframe流方式是在页面中插入一个隐藏的iframe，利用其src属性在服务器和客户端之间创建一条长连接，服务器向iframe传输数据（通常是HTML，内有负责插入信息的javascript），来实时更新页面。优点：消息能够实时到达；浏览器兼容好缺点：服务器维护一个长连接会增加开销；非动态设置iframe.srec时IE、chrome、Firefox会显示加载没有完成，图标会不停旋转,见下面两图实例1.index.html1234567891011121314151617181920212223242526&lt;!--index.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;longConnection&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;button onclick="longConnection()"&gt;http 长连接&lt;/button&gt; &lt;button onclick="stopLongConnection()"&gt;关闭长连接&lt;/button&gt; &lt;p id="longConnection"&gt;&lt;/p&gt; &lt;iframe id="iframe" src="" style="display:none"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;script&gt; var iframe = document.getElementById('iframe') function longConnection() &#123; iframe.src='/longConnection2' console.log(iframe) &#125; function stopLongConnection() &#123; iframe.src='/' &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;2.server.js123456789101112131415161718192021222324252627282930// server.jsconst port = 8001let path = require('path');let express = require('express'), //引入express模块 app = express(), server = require('http').createServer(app);app.use(express.static(path.join(__dirname, 'static'))); //指定静态HTML文件的位置app.get('/longConnection2',function(req,res)&#123; let count = 0 let longConnectionTimer = null clearInterval(longConnectionTimer) longConnectionTimer = setInterval(_ =&gt; &#123; if (res.socket._handle) &#123; console.log('longConnection2-' + count++) let date = new Date().toLocaleString() res.write(` &lt;script type="text/javascript"&gt; parent.document.getElementById('longConnection').innerHTML = "$&#123;date&#125;";//改变父窗口dom元素 &lt;/script&gt; `) &#125; else &#123; console.log('longConnection2-stop') clearInterval(longConnectionTimer) longConnectionTimer = null &#125; &#125;, 1000)&#125;);server.listen(port);server.setTimeout(0); //设置不超时，所以服务端不会主动关闭连接console.log('server started', 'http://127.0.0.1:' + port);3.效果图事件流 EventSource（SSE - Server-Sent Events，不能算作历史技术，属于H5范围）EventSource的官方名称应该是Server-sent events (SSE)服务端派发事件，EventSource 基于http协议只是简单的单项通信，实现了服务端推的过程客户端无法通过EventSource向服务端发送数据。虽然不能实现双向通信但是在功能设计上他也有一些优点比如可以自动重连接,event-IDs,以及发送随机事件的能力（WebSocket要借助第三方库比如socket.io可以实现重连。）实例1.index.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!--index.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;script src="https://unpkg.com/vue@2.6.10/dist/vue.min.js"&gt;&lt;/script&gt; &lt;title&gt;polling&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app"&gt; &lt;button @click="longConnection"&gt;http 长连接&lt;/button&gt; &lt;button @click="stopLongConnection"&gt;关闭长连接&lt;/button&gt; &lt;p&gt;&#123;&#123;time&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; window.onload=function()&#123; let vm=new Vue(&#123; el:'#app', data:&#123; time: '', eventSource: null &#125;, methods: &#123; stopLongConnection() &#123; this.close() &#125;, longConnection() &#123; this.getTime() &#125;, getTime()&#123; // 实例化 EventSource 对象，并指定一个 URL 地址 this.eventSource = new EventSource('/longConnection'); // 使用 addEventListener() 方法监听事件 console.log("当前状态0", this.eventSource.readyState); this.eventSource.onopen = this.onopen this.eventSource.onmessage = this.onmessage this.eventSource.onerror = this.onerror &#125;, onopen()&#123; console.log("链接成功."); console.log("当前状态1", this.eventSource.readyState); &#125;, onmessage(res)&#123; this.time = res.data &#125;, onerror(err)&#123; console.log(err) &#125;, close()&#123; this.eventSource &amp;&amp; this.eventSource.close() console.log("当前状态2", this.eventSource.readyState); &#125; &#125; &#125;); &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;2.server.js1234567891011121314151617181920212223242526272829303132// server.jsconst port = 8001let path = require('path');let express = require('express'), //引入express模块 app = express(), server = require('http').createServer(app);app.use(express.static(path.join(__dirname, 'static'))); //指定静态HTML文件的位置app.get('/longConnection',function(req,res)&#123; let count = 0 let longConnectionTimer = null clearInterval(longConnectionTimer) res.writeHead(200, &#123; 'Content-Type': "text/event-stream", 'Cache-Control': 'no-cache', 'Connection': 'keep-alive' &#125;) longConnectionTimer = setInterval(_ =&gt; &#123; if(res.socket._handle)&#123; console.log('longConnection-' + count++) const data = &#123; timeStamp: Date.now() &#125;; res.write(`data: $&#123;new Date().toLocaleString()&#125;\n\n`); &#125; else &#123; console.log('longConnection-stop') clearInterval(longConnectionTimer) longConnectionTimer = null res.end('stop'); &#125; &#125;, 1000)&#125;);server.listen(port);server.setTimeout(0); //设置不超时，所以服务端不会主动关闭连接console.log('server started', 'http://127.0.0.1:' + port);3.效果图有什么用：因为受单项通信的限制EventSource非常适应于后端数据更新频繁且对实时性要求较高而又不需要客户端向服务端通信的场景下。比如来实现像股票报价、新闻推送、实时天气这些只需要服务器发送消息给客户端场景中。EventSource的使用更加便捷这也是他的优点。EventSource的应用，webpack-hot-middleware原理优点基于现有http协议，实现简单断开后自动重联，并可设置重联超时派发任意事件跨域并有相应的安全过滤缺点只能单向通信，服务器端向客户端推送事件事件流协议只能传输UTF-8数据，不支持二进制流。兼容性不高，IE 和 Edge 下目前所有不支持EventSource服务器端需要保持 HTTP 连接，消耗一定的资源EventSource实例的readyState属性，表明连接的当前状态。该属性只读，可以取以下值。0：相当于常量EventSource.CONNECTING，表示连接还未建立，或者断线正在重连。1：相当于常量EventSource.OPEN，表示连接已经建立，可以接受数据。2：相当于常量EventSource.CLOSED，表示连接已断，且不会重连。注意:EventSource是一种服务端推送技术。一般来说，网页都是通过发送请求从服务端获取数据，而服务端推送技术 使服务器随时可以向客户端发送数据。EventSource基于http长链接客户端需要创建一个EventSource对象，服务端URI为参数服务端返回的响应报文的Content-Type须为text/event-stream。Flash Socket在页面中内嵌入一个使用了Socket类的Flash程序JavaScript通过调用此Flash程序提供的Socket接口与服务器端的Socket接口进行通信，JavaScript在收到服务器端传送的信息后控制页面的显示。优点：实现真正的即时通信，而不是伪即时。缺点：客户端必须安装Flash插件；非HTTP协议，无法自动穿越防火墙。实例：网络互动游戏。==Flash 不懂也不说太多了，再多说都是瞎编了==以上demo源码地址：https://github.com/liliuzhu/personalShareDemo/tree/master/WebSocket/pollingWebSocketWebSocket是HTML5开始提供的一种在单个TCP连接上进行全双工通讯的协议。WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。HTML5 定义的 WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯；解决了轮询以及其他长连接的很多缺点。如何使用 WebSocket12345678// WebSocket的客户端原生apivar Socket = new WebSocket('ws://localhost:8080') // WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。Socket.onopen = function()&#123;&#125; // 连接建立时触发Socket.onclose = function()&#123;&#125; // 连接关闭时触发Socket.onmessage = function()&#123;&#125; // 客户端接收服务端数据时触发Socket.send('data') // 实例对象的send()方法用于向服务器发送数据Socket.close() // 关闭连接socket.onerror = function()&#123;&#125; // 通信发生错误时触发Socket.readyState 表示连接状态，可以是以下值0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。注意：Websocket 使用ws或wss的统一资源标志符，类似于HTTPS，其中wss表示在TLS之上的WebsocketWebsocket 使用和HTTP相同的TCP端口，可以绕过大多数防火墙的限制。默认情况下，Websocket 协议使用 80 端口；运行在 TLS 之上时，默认使用 443 端口。虽然 WebSocketServer 可以使用别的端口，但是统一端口还是更优的选择123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。ws.onmessage = function(event)&#123; if(typeof event.data === String) &#123; console.log("Received data string"); &#125; if(event.data instanceof ArrayBuffer)&#123; var buffer = event.data; console.log("Received arraybuffer"); &#125;&#125;// 除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。// 收到的是 blob 数据ws.binaryType = "blob";ws.onmessage = function(e) &#123; console.log(e.data.size);&#125;;// 收到的是 ArrayBuffer 数据ws.binaryType = "arraybuffer";ws.onmessage = function(e) &#123; console.log(e.data.byteLength);&#125;;// 发送 Blob 对象的例子。var file = document .querySelector('input[type="file"]') .files[0];ws.send(file);// 发送 ArrayBuffer 对象的例子。// Sending canvas ImageData as ArrayBuffervar img = canvas_context.getImageData(0, 0, 400, 320);var binary = new Uint8Array(img.data.length);for (var i = 0; i &lt; img.data.length; i++) &#123; binary[i] = img.data[i];&#125;ws.send(binary.buffer);// 实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。var data = new ArrayBuffer(10000000);socket.send(data);if (socket.bufferedAmount === 0) &#123; // 发送完毕&#125; else &#123; // 发送还没结束&#125;WebSocket &amp; EventSource 的区别EventSource和WebSocket一样都是HTML5中的新技术,不过两者在定位上有很大的差别。WebSocket基于TCP协议，EventSource基于http协议。EventSource是单向通信，而websocket是双向通信。EventSource只能发送文本，而websocket支持发送二进制数据。在实现上EventSource比websocket更简单。EventSource有自动重连接（不借助第三方）以及发送随机事件的能力。websocket的资源占用过大EventSource更轻量。websocket可以跨域，EventSource基于http跨域需要服务端设置请求头。WebSocket 协议本质上是一个基于 TCP 的协议。为了建立一个 WebSocket连接，客户端浏览器首先要向服务器发起一个HTTP请求，这个请求和通常的HTTP请求不同，包含了一些附加头信息，其中附加头信息”Upgrade:WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。Websocket 其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是 HTTP 协议上的一种补充。废话不说上案例以上demo源码地址： https://github.com/liliuzhu/personalShareDemo/tree/master/WebSocket/webSocketWeb 实时推送技术的比较方式类型技术实现优点缺点适用场景轮询Pollingclient⇌server客户端循环请求1、实现简单 2、 支持跨域1、浪费带宽和服务器资源 2、 一次请求信息大半是无用（完整http头信息） 3、有延迟 4、大部分无效请求适于小型应用长轮询Long-Pollingclient⇌server服务器hold住连接，一直到有数据或者超时才返回，减少重复请求次数1、实现简单 2、不会频繁发请求 3、节省流量 4、延迟低1、服务器hold住连接，会消耗资源 2、一次请求信息大半是无用WebQQ、Hi网页版、Facebook IM长连接iframeserver⇌client在页面里嵌入一个隐蔵iframe，将这个 iframe 的 src 属性设为对一个长连接的请求，服务器端就能源源不断地往客户端输入数据。1、数据实时送达 2、不发无用请求，一次链接，多次“推送”1、服务器增加开销 2、无法准确知道连接状态 3、IE、chrome等一直会处于loading状态Gmail聊天EventSourceserver→clientnew EventSource()1、基于现有http协议，实现简单2、断开后自动重联，并可设置重联超时3、派发任意事件4、跨域并有相应的安全过滤1、只能单向通信，服务器端向客户端推送事件2、事件流协议只能传输UTF-8数据，不支持二进制流。4、兼容性不高，IE 和 Edge下目前所有不支持EventSource服务器端需要保持 HTTP 连接，消耗一定的资源股票报价、新闻推送、实时天气WebSocketserver⇌clientnew WebSocket()1、支持双向通信，实时性更强 2、可发送二进制文件3、减少通信量1、浏览器支持程度不一致 2、不支持断开重连网络游戏、银行交互和支付综上所述：Websocket协议不仅解决了HTTP协议中服务端的被动性，即通信只能由客户端发起，也解决了数据同步有延迟的问题，同时还带来了明显的性能优势，所以websocket是Web 实时推送技术的比较理想的方案，但如果要兼容低版本浏览器，可以考虑用轮询来实现。服务端的WebSocketnpm上有很多包对websocket做了实现比如 socket.io、WebSocket-Node、ws、nodejs-websocket还有很多Socket.io：Socket.io是一个WebSocket库，包括了客户端的js和服务器端的nodejs，它会自动根据浏览器从WebSocket、AJAX长轮询、Iframe流等等各种方式中选择最佳的方式来实现网络实时应用（不支持WebSocket的情况会降级到AJAX轮询），非常方便和人性化，兼容性非常好，支持的浏览器最低达IE5.5。屏蔽了细节差异和兼容性问题，实现了跨浏览器/跨设备进行双向数据通信。ws：不像 socket.io 模块，ws是一个单纯的websocket模块，不提供向上兼容，不需要在客户端挂额外的js文件。在客户端不需要使用二次封装的api使用浏览器的原生Websocket API即可通信。参考文献https://blog.csdn.net/yhb241/article/details/79713830https://www.tuicool.com/articles/FFFrUvyhttps://developer.mozilla.org/zh-CN/docs/Server-sent_events/EventSourcehttps://www.jianshu.com/p/958eba34a5dahttp://www.runoob.com/html/html5-websocket.html]]></content>
      <categories>
        <category>原创</category>
        <category>前端</category>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript实现经典排序算法]]></title>
    <url>%2Fblog%2F2019%2F04%2FJS-classicic-sorting-algorithms.html</url>
    <content type="text"><![CDATA[先看一下各个算法的时间复杂度和空间复杂度说明：时间复杂度：指的是一个算法执行所耗费的时间空间复杂度指：运行完一个程序所需内存的大小稳定指：如果a=b,a在b的前面，排序后a仍然在b的前面不稳定指：如果a=b，a在b的前面，排序后可能会交换位置下面主要通过文字和动图介绍冒泡排序、选择排序、快速排序和插入排序这些经典的排序算法，并用js代码实现1. 冒泡排序（Bubble Sort）冒泡排序可谓是最经典的排序算法了，它是基于比较的排序算法，其优点是实现简单，排序数量较小时性能较好。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。1. 1 算法原理相邻的数据进行两两比较，小数放在前面，大数放在后面，如果前面的数据比后面的数据大，就交换这两个数的位置。也可以实现大数放在前面，小数放在后面，如果前面的数据比后面的小，就交换两个的位置。要实现上述规则需要用到两层for循环。1. 2 算法描述比较相邻的元素。如果第一个比第二个大，就交换它们两个；对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；针对所有的元素重复以上的步骤，除了最后一个；重复步骤1~3，直到排序完成。1. 3 动图演示1. 4 js代码实现123456789101112131415161718192021function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; // 相邻元素两两对比 // 元素交换 /** 1.使用中间变量 **/ var temp = arr[j + 1]; arr[j + 1] = arr[j] arr[j] = temp /** 2.适用纯数字的数组排序 **/ arr[j] = arr[j] + arr[j + 1] arr[j + 1] = arr[j] - arr[j + 1] arr[j] -= arr[j + 1] /** 3.使用es6解构赋值 **/ [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]] &#125; &#125; &#125; return arr;&#125;冒泡排序算法优化12345678910111213141516function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len; i++) &#123; var exchange=false; // 交换标志 for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; // 相邻元素两两对比 [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]] // 元素交换 exchange=true; // &#125; &#125; if(!exchange)&#123; // 若本趟排序未发生交换，提前终止算法 break; &#125; &#125; return arr;&#125;2. 选择排序（Selection Sort）表现最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度。。。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。2. 1 算法原理先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。2. 2 算法描述n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：初始状态：无序区为R[1..n]，有序区为空；第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；n-1趟结束，数组有序化了。2. 3 动图演示2. 4 js代码实现12345678910111213141516function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; //寻找最小的数 minIndex = j; //将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125;3. 插入排序（Insertion Sort）插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。3. 1 算法原理它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。3. 2 算法描述一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：从第一个元素开始，该元素可以认为已经被排序；取出下一个元素，在已经排序的元素序列中从后向前扫描；如果该元素（已排序）大于新元素，将该元素移到下一位置；重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；将新元素插入到该位置后；重复步骤2~5。3. 3 动图演示3. 4 js代码实现1234567891011121314151617function insertSort(arr) &#123; // 从1位置开始遍历arr中每元素，同时声明空变量temp for (let i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; arr[i - 1]) &#123; // 如果当前元素&lt;前一个元素 let temp = arr[i] // 将当前元素值临时保存在temp中 let p = i - 1 // 定义变量 p = i- 1 // 循环 条件： // 1. p&gt;=0且temp小于p位置的元素 while (p &gt;= 0 &amp;&amp; temp &lt; arr[p]) &#123; // 循环体： 将P位置的值赋值给p的后一个元素 arr[p + 1] = arr[p] p-- // p向前移动一个 &#125; arr[p + 1] = temp // 将temp的值赋值给p+1位置的元素 &#125; &#125;&#125;4. 快速排序（Selection Sort）快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。4. 1 算法原理快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。4. 2 算法描述选基准：在数据结构中选择一个元素作为基准(pivot划分区：参照基准元素值的大小，划分无序区，所有小于基准元素的数据放入一个区间，所有大于基准元素的数据放入另一区间，分区操作结束后，基准元素所处的位置就是最终排序后它应该所处的位置递归：对初次划分出来的两个无序区间，递归调用第 1步和第 2步的算法，直到所有无序区间都只剩下一个元素为止。4. 3 动图演示4. 4 js代码实现12345678910111213141516171819202122function quickSort(arr)&#123; //如果arr.length&lt;=1,则直接返回arr if(arr.length&lt;=1)&#123;return arr&#125; // arr的元素个数/2，再下去整，将值保存在pivotIndex中 var pivotIndex=Math.floor(arr.length/2); // 将arr中pivotIndex位置的元素，保存在变量pivot中 var pivot=arr[pivotIndex]; //声明空数组left和right var left=[]; var right=[]; for(var i=0;i&lt;arr.length;i++)&#123; // 遍历arr中每个元素 if(i !== pivotIndex)&#123; // 如果i !== pivotIndex if(arr[i]&lt;=pivot)&#123; // 如果当前元素值&lt;pivot left.push(arr[i]); // 就将当前值压入left &#125;else&#123; right.push(arr[i]); // 就将当前值压入right &#125; &#125; &#125; //递归 return quickSort(left).concat(pivot, quickSort(right)); // 链接多个数组到 left 从小到大&#125;参考文献十大经典排序算法js排序算法汇总技术面试宝典： 很全面的算法和数据结构知识（含代码实现）下篇本文首发于个人技术博客 http://liliuzhu.gitee.io/blog]]></content>
      <categories>
        <category>原创</category>
        <category>前端</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【基础】利用 hexo + Gitpage 开发自己的博客]]></title>
    <url>%2Fblog%2F2019%2F03%2Fgitpage%2Bhexo_develop_blog.html</url>
    <content type="text"><![CDATA[原文作者：cherry原文地址：【基础】利用 hexo + Gitpage 开发自己的博客进入程序员这个坑之后就开始自己在网上扒资料，然而资料太多，情况太复杂，主要是看见别人的博客，感觉好高大上，并且感觉在茫茫的互联网有自己的小天地感觉也是极好的。不是为了给别人看，而是为了 记录自己的成长，记录自己的每一个脚印。Gitpage+hexo想要实现拥有一个独立的私有博客，我们需要两个东西，一个是可供浏览器访问的静态网页存储空间，这个我们选择gitPage，一个是一个静态网页生成工具，Octopress也好，Hexo也罢，这里我选择的是Hexo。环境准备1 安装Node到Node.js官网下载相应平台的最新版本，一路安装即可。我用的是node-v0.10.22-x86.msi2 安装Git安装git，或安装github客户端，自我感觉github客户端很好用，界面很友好，同样操作起来也比git好用的多！我用的是window10系统，在官网下载数次都未安装成功，最后在知乎上终于找到安装包，链接: http://pan.baidu.com/s/1eS2mHxS 密码: yatq ，有需要的同学可以点击下载。安装步骤1 安装Hexo使用git shell,依次输入以下代码命令：12cd /npm install hexo-cli -g命令解释：cd和/之间要有空格，这条指令的作用是返回根目录，也可以在cd /后加入一个文件名，例如下文要用到的cd /Hexo 就可以指向这个文件夹，再输入代码行就默认在在此文件下执行。2 安装博客所需文件123456cd /hexo init Hexocd /Hexonpm instalhexo generate（可简写为hexo g）hexo sever（可简写为hexo s）命令解释:cd /这里返回的根目录取决于你在github客户端的设置，我设置的是F盘，所以返回得也是F盘，所以下面创建的Hexo文件夹也在F盘。Hexo这个文件名可以随便命名，存放的是构建博客所要用到的所有文件。指向Hexo目录安装依赖文件编译开启本地服务(第5、6步的操作可以合并成hexo s -g)此时打开浏览器，在地址栏输入http://localhost:4000/即可查看博客的原型，是不是看到了胜利的曙光；但是如果“显示无法访问此网站”也不要沮丧，我这步是直接看到页面的，你无法访问的原因可能你没有翻墙，因为页面中默认使用了ajax.google.com 下的js包。那么如何翻墙呢？ 下面提供我所知道的两种方法：这种方法比较简单，下载安装运行Lantern，可以官网下载的吧！这里提供一下安装包吧，链接: http://pan.baidu.com/s/1c2x7eRu密码: z3kw这种方法需要修改hosts文件，我的 hosts 文件路径：C:\Windows\System32\drivers\etc ，详细攻略：http://blog.my-eclipse.cn/host-google.html如果你不想翻墙，可以采用这种方法：进入你刚新建好的 blog根目录1themes/landscape/layout/_partial1，找到 after-footer.ejs把1&lt;script src="http://cdn.bootcss.com/jquery/2.1.1/jquery.min.js“ &gt; &lt;/script&gt;替换成&lt;script src=&quot;http://cdn.bootcss.com/jquery/2.1.1/jquery.min.js“ &gt; &lt;/script&gt;2，找到 header.ejs注释掉或者删掉 下面这句css引用&lt;link href=&quot;//fonts.googleapis.com/css?family=Source+Code+Pro&quot; rel=”stylesheet” type=”text/css”&gt;hexo server 之后。访问 http://localhost:4000 就会看到blog主页了。如果你成功在http://localhost:4000/下看到了博客原型，那么再进行一些简单的操作之后就可以马上拥有自己的博客了，是不是很激动！行百里者半九十不到成功的那一刻，一切欣喜若狂都是不值得的！如果你已经迫不及待，我们继续：3 部署博客到服务器也就是把博客部署到github page提供的服务器上。步骤首先回到git shell按ctrl+c，之后输入y即可修改Hexo文件夹下_config.yml文件，如下图所示修改，repository后的地址要改成你自己的地址：deploy: type: github repo: https://github.com/yourname/blog.git继续回到git shell输入命令：1234hexo cleanhexo ghexo shexo d命令解释:清除public，当 source 文件夹中的部分资源更改过之后，特别是对文件进行了删除或者路径的改变之后，需要执行这个命令，然后重新编译。编译，一般部署上去的时候都需要编译一下，编译后，会出现一个 public 文件夹，将所有的md文件编译成html文件开启本地服务，部署博客到github上，如果一切顺利，你就通过访问usename.github.io访问你的博客了！是的，现在你拥有了自己的博客！发表博文千辛万苦建立了博客，那么我们来学习一下如何发表博文。新建博文继续回到git shell输入：hexo new “新博文的名字”即可在 Hexo\source_posts 目录中找到”新博文的名字.md”这个文件。你就可以使用maekdown编辑器打开进行编写博客内容了。Markdown编辑器推荐两款我所使用的markdown编辑器：MIU，据说是仿mac版的mou，界面相当友好，非常喜欢，官网都下载不了，挺小众，可能我就是典型的少说派，我也是偶然间得到，在此提供下载地址：链接: http://pan.baidu.com/s/1slMPeTR密码: 2pnk正在使用的Atom:更为先进的文本代码编辑器 ,由 Github 打造的下一代编程开发神器,其中支持markdown。可能会遇到的问题hexo new [layout] “postName” #新建文章其中layout是可选参数，默认值为post。有哪些layout呢，请到scaffolds目录下查看，这些文件名称就是layout名称。当然你可以添加自己的layout，方法就是添加一个文件即可，同时你也可以编辑现有的layout，比如post的layout默认是hexo\scaffolds\post.md1234title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags:---大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示。我想添加categories，以免每次手工输入，只需要修改这个文件添加一行12345title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;categories:tags:---postName是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围，postName可以为中文。注意，所有文件：后面都必须有个空格，不然会报错。看一下刚才生成的文件hexo\source_posts\postName.md12345title: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: #文章分类目录，可以为空，注意:后面有个空格tags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3]，注意:后面有个空格---始使用markdown格式输入你的正文。，你就可以用喜爱的编辑器尽情书写你的文章。关于markdown语法，可以参考我的文章Markdown简明语法。fancybox可能有人对这个Reading页面中图片的fancybox效果感兴趣，这个是怎么做的呢。很简单，只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片：1234567layout: phototitle: 我的阅历date: 2085-01-16 07:33:44tags: [hexo]photos:- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg经过测试，文件头上的layout: photo可以省略。不想每次都手动添加怎么办？同样的，打开您的hexo\scaffolds\photo.md1234567layout: &#123; &#123; layout &#125; &#125;title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags:photos:----然后每次可以执行带layout的new命令生成照片文章：1hexo new photo "photoPostName" #新建照片文章descriptionmarkdown文件头中也可以添加description，以覆盖全局配置文件中的description内容，请参考下文_config.yml的介绍。123456title: hexo你的博客date: 2013-11-22 17:11:54categories: defaulttags: [hexo]description: 你对本页的描述---hexo默认会处理全部markdown和html文件，如果不想让hexo处理你的文件，可以在文件头中加入layout: false。文章摘要在需要显示摘要的地方添加如下代码即可：123以上是摘要&lt;!--more--&gt;以下是余下全文more以上内容即是文章摘要，在主页显示，more以下内容点击『&gt; Read More』链接打开全文才显示。hexo中所有文件的编码格式均是UTF-8。优雅的在博客上插入图片看到很多博客上说使用七牛，但是这种方法可能是用着最爽的，我们来看一下如何使用：首先确认 _config.yml 中更改 post_asset_folder:true 。回到git shell，输入npm install https://github.com/CodeFalling/hexo-asset-image –save继续执行1234hexo cleanhexo ghexo shexo d重新创建一个博客名字，然后发现Hexo\source_posts下多了一个与博客名字相同的空文件夹然后就可以把我们博客中要用到的图片存放在这个文件夹下，需要时直接引用即可，是不是特别方便？提醒：写一篇博文时尽量只使用一种markdown编辑器，如果同时使用两个编辑器，我感觉不同编辑器对markdown语法的编译还是有一些差别的，用这个编辑器写好的格式用另一个编辑器打开却乱了！预览和发表继续重复以下命令即可实现预览和发表，恭喜你已经在自己建设的博客网站上发表了第一篇博文！12341. hexo clean2. hexo g3. hexo s4. hexo d更高大上的发表博文的方法使用Travis CI自动部署你的Hexo博客到Github,请参考手把手教你使用Travis CI自动部署你的Hexo博客到Github上使用could9在线更新博客，这样的话即使更换了电脑，也能优雅的更新博客了。详细请参考：用c9.io实现在线更新博客安装主题如果你跟我一样觉得原始的博客主题很low，想更换一个高逼格的，那我们继续往下进行：选择主题你可以在Themes·Hexo上选择你喜欢的主题，我使用的Next主题安装Next主题参考Next官方文档,内容十分详尽！安装主题的方法就是一句git命令：1git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist目录是否是modernist无所谓，只要与_config.yml文件一致即可。安装完成后，打开hexo_config.yml，修改主题为modernist1theme: modernist打开hexo\themes\modernist目录，编辑主题配置文件_config.yml：1234567891011121314151617181920212223242526272829menu: #配置页头显示哪些菜单# Home: / Archives: /archives Reading: /reading About: /about# Guestbook: /aboutexcerpt_link: Read More #摘要链接文字archive_yearly: false #按年存档widgets: #配置页脚显示哪些小挂件 - category# - tag - tagcloud - recent_posts# - blogrollblogrolls: #友情链接 - bruce sha's duapp wordpress: http://ibruce.duapp.com - bruce sha's javaeye: http://buru.iteye.com - bruce sha's oschina blog: http://my.oschina.net/buru - bruce sha's baidu space: http://hi.baidu.com/iburufancybox: true #是否开启fancybox效果duoshuo_shortname: buru #多说账号google_analytics:rss:更新主题12cd themes/modernistgit pull评论框静态博客要使用第三方评论系统，hexo默认集成的是Disqus，因为你懂的，所以国内的话还是建议用多说直接用你的微博/豆瓣/人人/百度/开心网帐号登录多说，做一下基本设置。如果使用modernist主题，在modernist_config.yml中配置duoshuo_shortname为多说的基本设置-&gt;域名中的shortname即可。你也可以在多说后台自定义一下多说评论框的格式，比如评论框的位置，对于css设置，可以参考这里，我是在HeroicYang的基础上修改的。如果你是有的其他第三方评论系统，将通用代码粘贴到hexo\themes\modernist\layout_partial\comment.ejs里面，如下：1234&lt;% if (config.disqus_shortname &amp;&amp; page.comments)&#123; %&gt;&lt;section id="comment"&gt; #你的通用代码&lt;% &#125; %&gt;构建新页面那些小图标都是一个新页面，需要手动创建，那么如何创建？回到git shell，hexo new page “页面名称”比如你要创建一个about页面，就输入hexo new page “about”正确显示各页面内容发表博文后发现点击上面建立的页面后发现是空白页，比如，打开标签页面，发现是空白，或者提示找不到！解决方法：以标签页为例，打开Hexo\source\tags下index.md文件，修改如下：comments: false即关闭此页面的评论功能type: “tags”这里的值根据你想更改的页面决定更改过后，在重新部署到github上，你就可以点击各个页面查看，发现一切都是那么美好！安装插件hexo支持的插件：Plugins | Hexo想安装什么插件，按照相关README.md中介绍操作即可。安装多说评论、不蒜子（或LeanCloud）和分享插件，参考:第三方服务集成，介绍非常全面！好好用来装饰你的博客吧！安装sitemap和feed插件时，如果遇到问题，可以参考:博客搬迁记 - 从WordPress到Hexo，安装sitemap后要到百度站长提交你的网站，首先要添加站点，然后在链接提交你的sitemap.xml，详细操作参考:为Hexo博客生成sitemap安装swiftype插件，如果遇到问题，可以参考利用swiftype为hexo添加站内搜索图床考虑到博客的速度，同时也为了便于博客的迁移，图床是必须的。我墙裂推荐七牛，访问速度极快，支持日志、防盗链和水印。免费用户有每月10GB流量+总空间10GB+PUT/DELETE 10万次请求+GET 100万次请求，这对个人博客来说足够，有一点要说明的是，七牛没有目录的概念，但是文件名可以包含/，比如2013/11/27/reading/photos-0.jpg，参考这里关于key-value存储系统。七牛除了作为图床还可以作为其他静态文件存储空间，比如我的个人站点首页有个字库文件和JS文件下载较慢，有时间会把它弄到七牛上去，以提高首页打开速度。请看这篇Linux中国采用七牛云存储支撑图片访问。如果非要说不足的话，就是文件管理界面不是很友好，不支持CNAME到分配的永久链接，也不能绑定未备案的自有域名，必须备案才可以。如果你对七牛web版的文件管理界面不满意，可以用官方的七牛云存储工具。您还可以使用如下图床服务 FarBox，Dropbox，又拍云主题优化Next主题很美观，个人也非常喜欢，但是一点令我们烦恼的就是主题加载的特别缓慢，那怎么优化呢？请参考一下两篇博文，作者已经总结的非常详细了，有需要的可以拜读一下，受益匪浅！提升Hexo的NexT主题加载速度使用gulp精简hexo博客代码绑定域名购买域名，我是在万网购买的，可以申请到国际域名，免去了备案的繁杂过程，我居然申请了两个，由于自学前端，所以就构建了一个网站来展示自己写的一些demo，【至于如何快速的构建一个网站，从购买域名，云空间到上传文件，你可以试一下这个网站,但是现在可以用github page做服务器，也可以构建多个项目主页来展现demo，是我马上要研究的方向，自己上传云服务器感觉步骤好繁琐，看一下在github建立项目主页能否得到改善！】还一个正好闲置着，所以就拿来解析到github page上，以后就可以通过自己的域名访问自己的博客了！如何操作：在 Hexo\source 文件夹里新建一个名为 CNAME 的文件，用文本编辑器打开，添加内容 yourwebsite.com （你的个人域名 ）。保存后，部署你的博客即可。如果这步遇到问题，也可手动在万网上解析，github page提供的IP：192.30.252.153192.30.252.154制作ICO图标favicon.ico一般用于作为缩略图的网站标志，在线制作网站关于是否绑定域名经过这几天的试用，关于是否绑定域名，发表一下自己的看法，如果你仅仅是使用个人主页来托管个人博客。绑定与否看你自己的想法，如果你还想使用github的项目主页来展示平时写的一些小练习demo，那我劝你不要绑定个人域名了，关于如何使用github的项目主页，请参考单个GitHub帐号下添加多个GitHub Pages的相关问题,这样你就可以直接在需要展示的项目下添加gh-pages分支，然后通过访问“用户名。github.io/项目名/*.html”来查看页面展示效果了。这多方便，不用自己在上传云空间了，省去了一堆麻烦事！#至此，基本操作介绍完毕，以下内容普通用户无需了解。默认目录结构：1234567891011.├── .deploy├── public├── scaffolds├── scripts├── source| ├── _drafts| └── _posts├── themes├── _config.yml└── package.jsondeploy：执行hexo deploy命令部署到GitHub上的内容目录public：执行hexo generate命令，输出的静态网页内容目录scaffolds：layout模板文件目录，其中的md文件可以添加编辑scripts：扩展脚本目录，这里可以自定义一些javascript脚本source：文章源码目录，该目录下的markdown和html文件均会被hexo处理。该页面对应repo的根目录，404文件、favicon.ico文件，CNAME文件等都应该放这里，该目录下可新建页面目录。drafts：草稿文章posts：发布文章themes：主题文件目录_config.yml：全局配置文件，大多数的设置都在这里package.json：应用程序数据，指明hexo的版本等信息，类似于一般软件中的关于按钮接下来是重头戏_config.yml，做个简单说明：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# Hexo Configuration## Docs: http://zespia.tw/hexo/docs/configure.html## Source: https://github.com/tommy351/hexo/# Site #整站的基本信息title: 不如 #网站标题subtitle: 码农，程序猿，未来的昏析师 #网站副标题description: bruce sha's blog | java | scala | bi #网站描述，给搜索引擎用的，在生成html中的head-&gt;meta中可看到author: bruce #网站作者，在下方显示email: bu.ru@qq.com #联系邮箱language: zh-CN #语言# URL #域名和文件结构## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://ibruce.info #你的域名root: /permalink: :year/:month/:day/:title/tag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/code# Writing #写文章选项new_post_name: :title.md # File name of new postsdefault_layout: post #默认layout方式auto_spacing: false # Add spaces between asian characters and western characterstitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabmax_open_file: 100multi_thread: truefilename_case: 0render_drafts: falsehighlight: #代码高亮 enable: true #是否启用 line_number: false #是否显示行号 tab_replace:# Category &amp; Tag #分类与标签default_category: uncategorized # defaultcategory_map:tag_map:# Archives #存档，这里的说明好像不对。全部选择1，这个选项与主题中的选项有时候会有冲突## 2: Enable pagination## 1: Disable pagination## 0: Fully Disablearchive: 1category: 1tag: 1# Server #本地服务参数## Hexo uses Connect as a server## You can customize the logger format as defined in## http://www.senchalabs.org/connect/logger.htmlport: 4000logger: truelogger_format:# Date / Time format #日期显示格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: MMM D YYYYtime_format: H:mm:ss# Pagination #分页设置## Set per_page to 0 to disable paginationper_page: 10 #每页10篇文章pagination_dir: page# Disqus #社会化评论disqus，我使用多说，在主题中配置disqus_shortname:# Extensions #插件，暂时未安装插件## Plugins: https://github.com/tommy351/hexo/wiki/Plugins## Themes: https://github.com/tommy351/hexo/wiki/Themes## 主题theme: modernist # raytaylorism # pacman # modernist # lightexclude_generator:# Deployment #部署## Docs: http://zespia.tw/hexo/docs/deploy.htmldeploy: type: github repository: git@github.com:bruce-sha/bruce-sha.github.com.git #你的GitHub Pages仓库修改局部页面页面展现的全部逻辑都在每个主题中控制，源代码在hexo\themes\你使用的主题\中，以modernist主题为例：123456789101112131415161718.├── languages #多语言| ├── default.yml #默认语言| └── zh-CN.yml #中文语言├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _partial #局部的布局，此目录下的*.ejs是对头尾等局部的控制| └── _widget #小挂件的布局，页面下方小挂件的控制├── source #源码| ├── css #css源码| | ├── _base #*.styl基础css| | ├── _partial #*.styl局部css| | ├── fonts #字体| | ├── images #图片| | └── style.styl #*.styl引入需要的css源码| ├── fancybox #fancybox效果源码| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md #用GitHub的都知道如果你需要修改头部，直接修改hexo\themes\modernist\layout_partial\header.ejs，比如头上加个搜索框：123456&lt;div&gt;&lt;form class="search" action="//google.com/search" method="get" accept-charset="utf-8"&gt; &lt;input type="search" name="q" id="search" autocomplete="off" autocorrect="off" autocapitalize="off" maxlength="20" placeholder="Search" /&gt; &lt;input type="hidden" name="q" value="site:&lt;%- config.url.replace(/^https?:\/\//, '') %&gt;"&gt;&lt;/form&gt;&lt;/div&gt;将如上代码加入即可，您需要修改css以便这个搜索框比较美观。再如，你要修改页脚版权信息，直接编辑hexo\themes\modernist\layout_partial\footer.ejs。同理，你需要修改css，直接去修改对应位置的styl文件。统计页面上显示访问次数可以使用 不蒜子，两行代码即可搞定。因Google Analytics偶尔被墙，故用百度统计，以modernist主题为例，介绍如何添加。编辑文件hexo\themes\modernist_config.yml，增加配置选项：1baidu_tongji: true新建文件hexo\themes\modernist\layout_partial\baidu_tongji.ejs，内容如下：12345&lt;% if (theme.baidu_tongji)&#123; %&gt;&lt;script type="text/javascript"&gt;#你的百度统计代码&lt;/script&gt;&lt;% &#125; %&gt;注册并登录百度统计获取你的统计代码。编辑文件hexo\themes\modernist\layout_partial\head.ejs，在『/head』之前增加：1&lt;%- partial('baidu_tongji') %&gt;重新生成并部署你的站点。不出意外的话，在你的站点的每个页面的左上角都会看到一个恶心的百度LOGO。你只能在『百度统计首页-&gt;网站列表-&gt;获取代码-&gt;系统管理设置-&gt;统计图标设置-&gt;显示图标』，把那个勾去掉。百度真是恶心，我准备还是用Google Analytics。分享我没有添加分享，觉得这个不是很必要，导致页面看起来啰嗦。以加网为例介绍如何添加：在hexo\themes\modernist\layout_partial\post下新建jiathis.ejs文件。注册加网获得你的分享代码，写入jiathis.ejs。在hexo\themes\modernist\layout_partial\article.ejs中，添加&lt;%-partial(‘post/jiathis’)%&gt;。-分享服务还可以使用如下企业提供的技术加网，bShare，百度分享。网站图标看一下hexo\themes\modernist\layout_partial\head.ejs，找到这句：1&lt;link rel="icon" type="image/x-icon" href="&lt;%- config.root %&gt;favicon.ico"&gt;你懂的，将你的favicon.ico放到工程根目录下即可，也就是hexo\source目录。可以在Faviconer制作你的ico图标，国内有比特虫。自定义挂件除了默认已提供的挂件外，你还可以自定义自己的小挂件，在hexo\themes\modernist\layout_widget\下，新建自己的ejs文件，如myWidget.ejs，然后在配置文件hexo\themes\modernist_config.yml中配置。12widgets: - myWidget用上述方法可以添加新浪微博小挂件。生成自己的微博组件。添加hexo\themes\modernist\layout_widget\weibo.ejs文件。配置hexo\themes\modernist_config.yml。插件安装插件：1npm install &lt;plugin-name&gt; --save启用插件：在*hexo_config.yml文件添加：12plugins:- &lt;plugin-name&gt; #插件名升级插件：1npm update卸载插件：1npm uninstall &lt;plugin-name&gt;RSS插件将上述命令中的『plugin-name』，替换为hexo-generator-feed。一旦安装完成，你可以在配置显示你站点的RSS，文件路径\atom.xml。你可以用rss作为迁移工具，用如下命令读取其他位置的rss：1hexo migrate rss &lt;source&gt;『source』是本地或网络文件路径。Sitemap插件将上述命令中的『plugin-name』，替换为hexo-generator-sitemap。你可以将你站点地图提交给搜索引擎，文件路径\sitemap.xml。更多插件的安装方法，请参考官方Wiki。如果你按照上述步骤做，但插件不起作用，没有生成atom.xml和sitemap.xml，也没有报错，那么你应该cd到你的hexo初始化目录，在该目录下重新安装插件，重试。迁移hexo支持从其他类型站点迁移，如通用RSS，Jekyll，Octopress，WordPress等，这一部分我没试过。请参考官方文档Hexo Migration。搜索引擎你可以到屈站长提交你的站点给搜索引擎。其他内容如添加站点或页面的description，提交Sitemap，添加百度统计，Google Analytics等等，参考本文其他章节的内容，不再一一阐述。更新更新hexo：1npm update -g hexo更新主题：12cd themes/你的主题git pull更新插件：1npm update干掉IEKill IE6 提示的javascript代码，请自行搜索。换机器你要保留好自己的博客源码。换机器写博客，就只能使用各种网盘的同步功能，或者你把你的站点源文件提交到某代码托管服务器。另外，貌似这篇很牛逼，Hexo 服务器端布署及 Dropbox 同步。我的办法是这样的，先在一个目录下做好Node+Git+Hexo的绿色环境，写个hexos.bat可以一键启动hexo工作台，把整个目录用Dropbox同步，这样随便在办公室或家的任何笔记本台式机都可以写博客，也不用处理什么文件拷贝备份的事情，非常爽。统计功能为hexo博客添加访问次数统计功能其它网站加速Webluker-CDN 网站加速 免费CDN DNS解析Webluker-FAQ索引网站监控监控宝-网站监控 网页监控 服务器监控监控宝-常见问题参考文献hexo + github + 多说 来搭建免费博客利用swiftype为hexo添加站内搜索博客搬迁记 - 从WordPress到Hexo在 hexo中无痛使用本地图片手把手教你使用Travis CI自动部署你的Hexo博客到Github上为Hexo博客生成sitemap使用gulp精简hexo博客代码单个GitHub帐号下添加多个GitHub Pages的相关问题hexo你的博客本文首发于个人技术博客 http://liliuzhu.gitee.io/blog]]></content>
      <categories>
        <category>Hexo</category>
        <category>转载</category>
      </categories>
      <tags>
        <tag>Hexo建站</tag>
        <tag>Githubpages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建可通过外网访问的内网服务器]]></title>
    <url>%2Fblog%2F2017%2F12%2FIntranet_mapping.html</url>
    <content type="text"><![CDATA[这是本人，第一次写博客，文采不好，技术也菜鸟，请不要见怪。前一段时间裸辞了，于是开始广投简历。可是现实是非常的残酷，年底了面试的通知很少。想着是不是自己的简历上干货太少了，不如把自己之前做的项目连接放在简历上。可是可是。。。，现实又很残酷。我们做的项目大多是企业内部系统，只能通过内网来访问。更为严重的是我们的主管是不会告诉我们客户的正式服务器的。出来面试，连作品连接都没有，都不好意思说自己是做web前端的[尴尬]。那怎么办呢？没有作品链接，简历被淘汰的概率也会大好多，后来想起来可以用自己的电脑搭建一台服务器，说干就干。后来找到了一些免费的第三方工具并且都一一实验了一下，有些成功了，有些也失败了。ittun但是可能是我的网络环境的问题，实际用的时候却是这样的结果第一个内网映射工具，使用失败。附上官网地址http://www.ittun.com/localtunnel也是网上找的，是基于Node.js的一个模块，说是可以将内网服务器暴露至公网。基于node.js，倒很适合我的胃口。结果也试几次还是失败。也可能是我用的方法还不对，继续寻找。JNat终于这个是可以用的了，试了几次除了速度慢一些，还都好用，不过需要这个工具需要在官网上申请免费的key，而且一个帐号只能申请一个免费的key，可以指定二级域名。不过后来测试的时候还是发现了一个问题，就是在客户端上传文件的JNat会出现错误，而且文件上传失败.希望以后能够得到解决。在此附上JNat官网地址http://www.j2eeall.comnatapp这个工具也是比较好用的，不过也需要去官网注册，而且还要实名认证，还是比较麻烦的。一个注册用户可免费拥有2条不同协议的隧道。客户端上传文件时也没有问题。不过这个工具也有不好的地方，就是免费版不能自定义二级域名。过一段时间不用，再去重新开启映射就会随机更新一个二级域名，这点比较坑，要是在app中应用岂不也是每次更新了二级域名，都要重新打包不可。不过，这已经不错了，毕竟人家是免费的[呲牙]！附上官方网址https://natapp.cnSunny-Ngrok这是最近才发现的一个内网穿透工具，好像还挺好用，官网讨论群也比较多。官网上介绍的也比较详细。官网上说其具有以下几方面优点：提供免费内网穿透服务，免费服务器支持绑定自定义域名管理内网服务器，内网web进行演示快速开发微信程序和第三方支付平台调试本地WEB外网访问、本地开发微信、TCP端口转发本站新增FRP服务器，基于 FRP 实现https、udp转发无需任何配置，下载客户端之后直接一条命令让外网访问您的内网不再是距离然而对于我来收说比较的可悲，和ittun一样都存在着一样的问题—无法连接应该和ittun想同的原因，也不知道该怎么破，还在的等待技术群的回复。附上官网链接https://www.ngrok.cc/本文首发于个人技术博客 http://liliuzhu.gitee.io/blog]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>内网映射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2F2017%2F12%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment]]></content>
  </entry>
</search>
